// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

import { IERC20 } from "openzeppelin/token/ERC20/IERC20.sol";
import { SafeERC20 } from "openzeppelin/token/ERC20/utils/SafeERC20.sol";
import { Ownable } from "owner-manager/Ownable.sol";
import { RNGInterface } from "rng/RNGInterface.sol";

/**
 * @title PoolTogether V5 RNGRequestor
 * @author PoolTogether Inc. Team
 * @notice The RNGRequestor allows anyone to request a RNG using the RNG service set.
 *         This contract can be inherited by other contracts and use the `_afterRNGComplete` hook
 *         to make use of the random number generated by the RNG.
 */
contract RNGRequestor is Ownable {
  using SafeERC20 for IERC20;

  /* ============ Structs ============ */

  /**
   * @notice RNG Request.
   * @param id          RNG request ID
   * @param lockBlock   Block number at which the RNG request is locked
   * @param requestedAt Time at which the RNG was requested
   */
  struct RNGRequest {
    uint32 id;
    uint32 lockBlock;
    uint64 requestedAt;
  }

  /* ============ Variables ============ */

  /// @notice RNG instance.
  RNGInterface internal _rng;

  /// @notice Current RNG Request.
  RNGRequest internal _rngRequest;

  /**
   * @notice RNG Request Timeout.
   * @dev If the RNG request timeouts, anyone can call `cancelRNGRequest` to cancel the pending the request.
   */
  uint32 internal _rngTimeout;

  /* ============ Custom Errors ============ */

  /// @notice Thrown when the RNG address passed to the setter function is zero address.
  error RNGNotZeroAddress();

  /**
   * @notice Thrown when the RNG Timeout passed to the setter function is lower than 60 seconds.
   * @param rngTimeout RNG Timeout value
   */
  error RNGTimeoutLT60Seconds(uint32 rngTimeout);

  /// @notice Thrown if the RNG has not timed out.
  error RNGHasNotTimedout();

  /// @notice Thrown if a RNG request is currently being processed.
  error RNGInProgress();

  /// @notice Thrown if the next Draw has not finished yet.
  error NextDrawNotFinished();

  /**
   * @notice Thrown if the RNG has been requested and is in progress.
   * @param requestId ID of the RNG request
   */
  error RNGRequested(uint32 requestId);

  /// @notice Thrown if calling `completeRNGRequest` and the RNG has not been requested.
  error RNGNotRequested();

  /**
   * @notice Thrown if calling `completeRNGRequest` and the RNG request has not been completed yet.
   * @param requestId ID of the RNG request
   */
  error RNGNotCompleted(uint32 requestId);

  /* ============ Events ============ */

  /**
   * @notice Emitted when an RNG request has started.
   * @param rngRequestId ID of the RNG request
   * @param rngLockBlock Block when RNG request becomes invalid
   */
  event RNGRequestStarted(uint32 indexed rngRequestId, uint32 rngLockBlock);

  /**
   * @notice Emitted when an RNG request has been completed.
   * @param rngRequestId ID of the RNG request
   * @param randomNumber Random number generated
   */
  event RNGRequestCompleted(uint32 indexed rngRequestId, uint256 randomNumber);

  /**
   * @notice Emitted when an RNG request has been cancelled.
   * @param rngRequestId ID of the RNG request
   * @param rngLockBlock Block when RNG request became invalid
   */
  event RNGRequestCancelled(uint32 indexed rngRequestId, uint32 rngLockBlock);

  /**
   * @notice Emitted when the RNG service address is set.
   * @param rngService RNG service address
   */
  event RNGServiceSet(RNGInterface indexed rngService);

  /**
   * @notice Emitted when the RNG timeout is set.
   * @param rngTimeout RNG timeout in seconds
   */
  event RNGTimeoutSet(uint32 rngTimeout);

  /* ============ Constructor ============ */

  /**
   * @notice Deploy the RNGRequestor smart contract.
   * @param rng_ Address of the RNG service
   * @param rngTimeout_ Time in seconds before an RNG request can be cancelled
   * @param _owner Address of the RNGRequestor owner
   */
  constructor(RNGInterface rng_, uint32 rngTimeout_, address _owner) Ownable(_owner) {
    _setRNGService(rng_);
    _setRNGTimeout(rngTimeout_);
  }

  /* ============ Modifiers ============ */

  /// @notice Reverts if an RNG request is in progress.
  modifier requireRNGNotInProgress() {
    if (_rngRequest.lockBlock != 0 || _rngRequest.lockBlock > block.number) revert RNGInProgress();
    _;
  }

  /**
   * @notice Reverts if an RNG request has been requested.
   * @dev This RNG request could be in progress, completed or have timed out.
   */
  modifier requireCanStartRNGRequest() {
    if (_isRNGRequested()) revert RNGRequested(_rngRequest.id);
    _;
  }

  /// @notice Reverts if an RNG request has not been requested or has not completed yet.
  modifier requireCanCompleteRNGRequest() {
    if (!_isRNGRequested()) revert RNGNotRequested();
    if (!_isRNGCompleted()) revert RNGNotCompleted(_rngRequest.id);
    _;
  }

  /* ============ External Functions ============ */

  /**
   * @notice Starts the RNG Request.
   * @dev Will revert if an RNG request has already been requested.
   * @dev If the RNG Service request a `feeToken` for payment,
   *      the RNG-Request-Fee is expected to be held within this contract before calling this function.
   * @param _rewardRecipient Address that will receive the auction reward for starting the RNG request
   */
  function startRNGRequest(address _rewardRecipient) external requireCanStartRNGRequest {
    (address _feeToken, uint256 _requestFee) = _rng.getRequestFee();

    if (_feeToken != address(0) && _requestFee > 0) {
      IERC20(_feeToken).safeIncreaseAllowance(address(_rng), _requestFee);
    }

    (uint32 _requestId, uint32 _lockBlock) = _rng.requestRandomNumber();
    _rngRequest.id = _requestId;
    _rngRequest.lockBlock = _lockBlock;
    _rngRequest.requestedAt = _currentTime();

    _afterRNGStart(_rewardRecipient);

    emit RNGRequestStarted(_requestId, _lockBlock);
  }

  /**
   * @notice Completes the RNG request.
   * @dev Will revert if no RNG has been requested or if the RNG request has not completed yet.
   * @param _rewardRecipient Address that will receive the auction reward for completing the RNG request
   */
  function completeRNGRequest(address _rewardRecipient) external requireCanCompleteRNGRequest {
    uint32 _rngRequestId = _rngRequest.id;
    uint256 _randomNumber = _rng.randomNumber(_rngRequestId);

    delete _rngRequest;

    _afterRNGComplete(_randomNumber, _rewardRecipient);

    emit RNGRequestCompleted(_rngRequestId, _randomNumber);
  }

  /// @notice Can be called by anyone to cancel the RNG request if it has timed out.
  function cancelRNGRequest() external {
    if (!_isRNGTimedOut()) revert RNGHasNotTimedout();

    uint32 _requestId = _rngRequest.id;
    uint32 _lockBlock = _rngRequest.lockBlock;

    delete _rngRequest;

    emit RNGRequestCancelled(_requestId, _lockBlock);
  }

  /* ============ State Functions ============ */

  /**
   * @notice Returns whether an RNG request has been requested or not.
   * @return True if an RNG request has been requested, false otherwise.
   */
  function isRNGRequested() external view returns (bool) {
    return _isRNGRequested();
  }

  /**
   * @notice Returns whether the RNG request has completed or not.
   * @return True if the RNG request has completed, false otherwise.
   */
  function isRNGCompleted() external view returns (bool) {
    return _isRNGCompleted();
  }

  /**
   * @notice Returns whether the RNG request has timed out or not.
   * @return True if the RNG request has timed out, false otherwise.
   */
  function isRNGTimedOut() external view returns (bool) {
    return _isRNGTimedOut();
  }

  /**
   * @notice Returns whether the RNG request can be started or not.
   * @return True if the RNG request can be started, false otherwise.
   */
  function canStartRNGRequest() external view returns (bool) {
    return !_isRNGRequested();
  }

  /**
   * @notice Returns whether the RNG request can be completed or not.
   * @return True if the RNG request can be completed, false otherwise.
   */
  function canCompleteRNGRequest() external view returns (bool) {
    return _isRNGRequested() && _isRNGCompleted();
  }

  /* ============ Getter Functions ============ */

  /**
   * @notice Returns the block number at which the current RNG request has been locked to.
   * @return The block number at which the RNG request is locked to.
   */
  function getRNGLockBlock() external view returns (uint32) {
    return _rngRequest.lockBlock;
  }

  /**
   * @notice Returns the ID of the current RNG request.
   * @dev Will return 0 if there is no RNG request in progress.
   * @return ID of the current RNG request
   */
  function getRNGRequestId() external view returns (uint32) {
    return _rngRequest.id;
  }

  /**
   * @notice Returns the RNG timeout in seconds.
   * @return RNG timeout in seconds
   */
  function getRNGTimeout() external view returns (uint32) {
    return _rngTimeout;
  }

  /**
   * @notice Returns the RNG service used to generate random numbers.
   * @return RNG service instance
   */
  function getRNGService() external view returns (RNGInterface) {
    return _rng;
  }

  /* ============ Setters ============ */

  /**
   * @notice Sets the RNG service used to generate random numbers.
   * @dev Only callable by the owner.
   * @dev Will revert if an RNG request is in progress.
   * @param _rngService Address of the new RNG service
   */
  function setRNGService(RNGInterface _rngService) external onlyOwner requireRNGNotInProgress {
    _setRNGService(_rngService);
  }

  /**
   * @notice Allows the owner to set the RNG request timeout in seconds. This is the time that must elapsed before the RNG request can be cancelled.
   * @dev Only callable by the owner.
   * @dev Will revert if an RNG request is in progress.
   * @param rngTimeout_ RNG request timeout in seconds
   */
  function setRNGTimeout(uint32 rngTimeout_) external onlyOwner requireRNGNotInProgress {
    _setRNGTimeout(rngTimeout_);
  }

  /* ============ Internal Functions ============ */

  /**
   * @notice Hook called after the RNG request has started.
   * @param _rewardRecipient Address that will receive the auction reward for starting the RNG request
   */
  function _afterRNGStart(address _rewardRecipient) internal virtual {}

  /**
   * @notice Hook called after the RNG request has completed.
   * @param _randomNumber The random number that was generated
   * @param _rewardRecipient Address that will receive the auction reward for completing the RNG request
   */
  function _afterRNGComplete(uint256 _randomNumber, address _rewardRecipient) internal virtual {}

  /**
   * @notice Returns the current timestamp.
   * @return The current timestamp.
   */
  function _currentTime() internal view virtual returns (uint64) {
    return uint64(block.timestamp);
  }

  /**
   * @notice Returns whether an RNG has been requested or not.
   * @return True if an RNG has been requested, false otherwise.
   */
  function _isRNGRequested() internal view returns (bool) {
    return _rngRequest.id != 0;
  }

  /**
   * @notice Returns whether the RNG request has completed or not.
   * @return True if the RNG request has completed, false otherwise.
   */
  function _isRNGCompleted() internal view returns (bool) {
    return _rng.isRequestComplete(_rngRequest.id);
  }

  /**
   * @notice Returns whether the RNG request has timed out or not.
   * @return True if the RNG request has timed out, false otherwise.
   */
  function _isRNGTimedOut() internal view returns (bool) {
    if (_rngRequest.requestedAt == 0) {
      return false;
    } else {
      return _rngTimeout + _rngRequest.requestedAt < _currentTime();
    }
  }

  /**
   * @notice Sets the RNG service used to generate random numbers.
   * @param rng_ Address of the new RNG service
   */
  function _setRNGService(RNGInterface rng_) internal {
    if (address(rng_) == address(0)) revert RNGNotZeroAddress();
    _rng = rng_;
    emit RNGServiceSet(rng_);
  }

  /**
   * @notice Sets the RNG request timeout in seconds. This is the time that must elapse before the RNG request can be cancelled.
   * @param rngTimeout_ RNG request timeout in seconds
   */
  function _setRNGTimeout(uint32 rngTimeout_) internal {
    if (rngTimeout_ < 60) revert RNGTimeoutLT60Seconds(rngTimeout_);
    _rngTimeout = rngTimeout_;
    emit RNGTimeoutSet(rngTimeout_);
  }
}
